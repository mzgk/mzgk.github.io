<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | jubilee]]></title>
  <link href="http://mzgk.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://mzgk.github.io/"/>
  <updated>2014-08-29T14:25:17+09:00</updated>
  <id>http://mzgk.github.io/</id>
  <author>
    <name><![CDATA[mzgk]]></name>
    <email><![CDATA[mzgkworks@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AppID・証明書の作成方法（Push通知あり）]]></title>
    <link href="http://mzgk.github.io/blog/2014/make-appid-certificate-for-pushnotification/"/>
    <updated>2014-08-28T16:42:34+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/make-appid-certificate-for-pushnotification</id>
    <content type="html"><![CDATA[<p>作成しているアプリ用に、App ID・証明書等の作成が必要になったので手順のメモ。<br/>
Push通知ありのアプリ。以下で作業が必要になる。</p>

<ul>
<li>Web（Safari &ndash;> iOS Developer Center）</li>
<li>Mac（キーチェーン・ターミナル）</li>
</ul>


<!-- more -->


<h2>App IDの作成（Web）</h2>

<ul>
<li>Safari &ndash;> iOS Developer Centerにアクセス</li>
<li>Certificates, Identifiers &amp; Profiles</li>
<li>iOS Apps</li>
<li>Identifiers &ndash;> App IDs</li>
<li>＋ボタンで作成開始</li>
<li>App ID Description

<ul>
<li>Name: 名前を入れる（判別しやすいように）</li>
</ul>
</li>
<li>App ID Prefix

<ul>
<li>Value: 自動生成されている（入力不可）</li>
</ul>
</li>
<li>App ID Suffix

<ul>
<li>Explicit App ID</li>
<li>Bundle ID: jp.co.ast-net.アプリ名（小文字）</li>
</ul>
</li>
<li>App Services

<ul>
<li>使用するものにチェックを入れる（今回はPush Notifications）</li>
</ul>
</li>
</ul>


<h2>証明書の作成（Mac）</h2>

<ul>
<li>キーチェーンアクセス.appを起動</li>
<li>メニューから、キーチェーンアクセス &ndash;> 証明書アシスタント &ndash;> 認証局に証明書を要求</li>
<li>入力欄

<ul>
<li>メールアドレス：入力</li>
<li>通称：入力</li>
<li>CAのメールアドレス：未入力</li>
</ul>
</li>
<li>チェック欄

<ul>
<li>ディスクに保存</li>
<li>鍵ペア情報を指定</li>
</ul>
</li>
<li>作成される「CertificateSigningRequest.certSigningRequest」（CSR）を任意の場所に保存</li>
<li>鍵サイズ：2048</li>
<li>アルゴリズム：RSA</li>
</ul>


<h2>App IDと証明書の設定（Web）</h2>

<ul>
<li>ここからは開発用（Development）と製品用（Distribution）の２回作業が必要</li>
<li>Safari &ndash;> iOS Developer Centerにアクセス</li>
<li>Certificates, Identifiers &amp; Profiles</li>
<li>iOS Apps</li>
<li>Identifiers &ndash;> App IDs</li>
<li>先ほど作成したApp IDを選択 &ndash;> Edit（Push Notificationsが黄色になっている）</li>
<li>Push Notificationsの「Development SSL Certificate &ndash;> Create Certificate&hellip;」をクリック</li>
<li>Continueをクリック</li>
<li>Chose File&hellip; で、作成した証明書（CSR）を選択</li>
<li>Generateをクリック</li>
<li>作成されたら、Downloadをクリックしダウンロードする</li>
<li>aps_development.cer（aps_production.cer）がダウンロードされる</li>
<li>Certificates &ndash;> Allには設定した分が増えている（Name: Bundle ID）</li>
</ul>


<h2>証明書の書き出し（Mac）</h2>

<ul>
<li>ダウンロードしたファイル（aps_development.cer）をダブルクリックして、キーチェーンに登録する</li>
<li>キーチェーン.appを起動</li>
<li>Apple Development IOS Push Services: Bundle IDが登録されているので選択し、右クリック</li>
<li>&ldquo;Apple Development IOS Push Services: Bundle ID"を書き出すをクリック</li>
<li>名前をつけて、任意の場所に保存。フォーマット：個人情報交換（.p12）</li>
<li>パスワードを作成</li>
</ul>


<h2>証明書の変換（Mac）</h2>

<ul>
<li>ターミナルを起動</li>
<li>ファイルのあるディレクトリに移動</li>
<li>コマンドを入力し、パスワードを入力</li>
<li>終了すると、証明書の名前.pemが作成される</li>
<li>作成された.pemファイルを通知処理を行うサーバーに置いておく</li>
</ul>


<p><code>bash
// 入力
$ openssl pkcs12 -in 証明書の名前.p12 -out 証明書の名前（p12と別でも可）.pem -nodes -clcerts
// 聞かれる
Enter Import Password: 証明書の書き出しで作成したパスワード
// 完了
MAC Verified OK
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ディレクトリ内を検索し、対象の文字列を含むディレクトリ・ファイルを削除]]></title>
    <link href="http://mzgk.github.io/blog/2014/search-and-delete/"/>
    <updated>2014-08-26T17:01:43+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/search-and-delete</id>
    <content type="html"><![CDATA[<p>~/tmpディレクトリ内に存在する「capture」の文字列を含むディレクトリ・ファイルを削除したい。<br/>
ワイルドカードが使えないみたいなので、以下で対応。</p>

<p>```objective-c
&ndash; (void)deleteTmpCaptureDir
{</p>

<pre><code>NSFileManager *manager = [NSFileManager defaultManager];
NSError *error = nil;
// ~/tmpディレクトリの取得
NSString *tmpDir = NSTemporaryDirectory();
// tmpディレクトリ内の一覧取得
NSArray *list = [manager contentsOfDirectoryAtPath:tmpDir error:&amp;error];
// 一覧の中から「capture」を含むディレクトリ・ファイルを検索
for (NSString *path in list) {
    NSRange range = [path rangeOfString:@"capture"];
    // 存在したならば削除
    if (NSNotFound != range.location) {
        NSString *target = [tmpDir stringByAppendingPathComponent:path];
        [manager removeItemAtPath:target error:&amp;error];
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[１つの画面の上下で同じViewControllerを使う方法（addChildViewController）]]></title>
    <link href="http://mzgk.github.io/blog/2014/addchiledviewcontroller/"/>
    <updated>2014-08-22T18:18:14+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/addchiledviewcontroller</id>
    <content type="html"><![CDATA[<ul>
<li>１つの画面（A-ViewController）の上下にImageViewとスライダーを表示し、 同じ処理をさせる必要があった</li>
<li>画面上に２つずつUIImageViewとUISliderを配置して制御してもいいけど、同じことするのは面倒</li>
<li>同じ処理なので１つのViewController（UIImageViewとUISliderを持った）を作成（MovieVCとする）</li>
<li>大元の画面（A-ViewController）で、上下に作成したMovieVCを呼べばいいのでは？</li>
<li>Container ViewController？</li>
</ul>


<!-- more -->


<p>テスト用にMovieViewはWebを表示するようにして、作成してみた。こんな感じ。<br/>
<img src="/images/2014/0822/image.png" alt="image" /></p>

<p>StoryBoardは、こんな感じで設定。<br/>
<img src="/images/2014/0822/storyboard.png" alt="image" /></p>

<h2>大元の画面（A-ViewController）</h2>

<p>.m</p>

<p>```objective-c
// MovieVCをインポート</p>

<h1>import &ldquo;MovieViewController.h&rdquo;</h1>

<p>@interface DetailViewController ()
// 画面の上下にUIViewを配置して接続
@property (weak, nonatomic) IBOutlet UIView <em>upperView;
@property (weak, nonatomic) IBOutlet UIView </em>lowerView;</p>

<p>// MovieVCのプロパティを用意
@property (nonatomic) MovieViewController <em>upperMovieVC;
@property (nonatomic) MovieViewController </em>lowerMovieVC;
@end</p>

<p>@implementation DetailViewController
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];

// MovieVCのインスタンスを生成（[MovieViewController new]ではダメ）
_upperMovieVC = [self.storyboard instantiateViewControllerWithIdentifier:@"MovieScene"];
_lowerMovieVC = [self.storyboard instantiateViewControllerWithIdentifier:@"MovieScene"];

// 自身のVCの子とする
[self addChildViewController:_upperMovieVC];
[self addChildViewController:_lowerMovieVC];

// 用意してあるUIViewに生成した子（MovieVC）のviewを追加
[_upperView addSubview:_upperMovieVC.view];
[_lowerView addSubview:_lowerMovieVC.view];

// 子に追加した旨を通知
[_upperMovieVC didMoveToParentViewController:self];
[_lowerMovieVC didMoveToParentViewController:self];

// テストのために用意したMovieVCのメソッドに違うURLを渡す
[_upperMovieVC connectURL:@"http://google.co.jp"];
[_lowerMovieVC connectURL:@"http://yahoo.co.jp"];
</code></pre>

<p>}
@end
```</p>

<h2>MovieVC</h2>

<p>.h</p>

<p><code>objective-c
@interface MovieViewController : UIViewController&lt;UIWebViewDelegate&gt;
- (void)connectURL:(NSString *)urlString;
@end
</code></p>

<p>.m</p>

<p>```objective-c
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
NSLog(@"MovieView viewDidLoad");
</code></pre>

<p>}</p>

<ul>
<li><p>(void)connectURL:(NSString <em>)urlString
{
  NSURL </em>url = [NSURL URLWithString:urlString];
  NSURLRequest *request = [NSURLRequest requestWithURL:url];
  <em>webView.delegate = self;
  [</em>webView loadRequest:request];
}</p></li>
<li><p>(void)willMoveToParentViewController:(UIViewController *)parent
{
  NSLog(@&ldquo;MovieVC&rdquo;);
}
```</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIActionSheetでタップされたボタンのタイトルを取得する]]></title>
    <link href="http://mzgk.github.io/blog/2014/uiactionsheet-tapped-buttontitle/"/>
    <updated>2014-08-22T13:52:26+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/uiactionsheet-tapped-buttontitle</id>
    <content type="html"><![CDATA[<p>UIActionSheetで、タップされたボタンのタイトルを取得する方法。</p>

<p>```objective-c
&ndash; (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex
{</p>

<pre><code>// キャンルボタンかどうかの判断（おまけ）
if (buttonIndex != actionSheet.cancelButtonIndex) {
    // タップされたボタンのタイトルを取得
    _label.text = [actionSheet buttonTitleAtIndex:buttonIndex];
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreDataのマイグレーション（その１）]]></title>
    <link href="http://mzgk.github.io/blog/2014/coredata-migration/"/>
    <updated>2014-08-22T13:35:20+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/coredata-migration</id>
    <content type="html"><![CDATA[<p>CoreDataを使ったアプリで、リリース後にエンティティに属性を追加したい場合の対応方法。<br/>
もちろん、今のデータを保持したままマイグレーションさせるのが前提。</p>

<ul>
<li>MagicalRecord使用済み</li>
<li>アプリリリース後にエンティティに属性を追加する</li>
<li>当然、今保存されているデータは引継がれることが前提</li>
</ul>


<h2>MagicalRecord</h2>

<p>セットアップ部分。<br/>
AppDelegate.m</p>

<p>```objective-c
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>...
// .xcdatamodelがプロジェクト名と違うし、自動マイグレーションしてほしい（最初から設定済み）
[MagicalRecord setupCoreDataStackWithAutoMigratingSqliteStoreNamed:@"Model.sqlite"];
...
</code></pre>

<p>}
```</p>

<h3>どのセットアップメソッドを使用するか</h3>

<p>ここを参考：<a href="http://www.raywenderlich.com/56879/magicalrecord-tutorial-ios">http://www.raywenderlich.com/56879/magicalrecord-tutorial-ios</a></p>

<p>CoreDataを作成した際の <code>{任意の名前}.xcdatamodel</code> が、プロジェクト名と同じであれば</p>

<ul>
<li>setupCoreDataStack</li>
<li>setupCoreDataStackWithInMemoryStore</li>
<li>setupAutoMigratingCoreDataStack</li>
</ul>


<p>違うならば</p>

<ul>
<li>setupCoreDataStackWithStoreNamed:</li>
<li>setupCoreDataStackWithAutoMigratingSqliteStoreNamed:</li>
</ul>


<p><code>AutoMigrating</code> がついている方は、属性追加などをした際に可能であれば自動でマイグレーションしてくれる。</p>

<h2>Xcode</h2>

<h3>Modelのバージョンを追加</h3>

<p><code>{任意の名前}.xcdatamodel</code> を選択し、Editor &ndash;> Add Model Version&hellip;<br/>
<img src="/images/2014/0822/addmodelversion.png" alt="Model Version" /></p>

<p><img src="images/2014/0822/addModel2.png" alt="Model2" /></p>

<h3>新しく追加したModelに属性を追加</h3>

<p>新しく追加した方のモデル（Model2）に属性を追加する。</p>

<h3>Current Versionの変更</h3>

<ul>
<li>Model.xcdatamodeledを選択する</li>
<li>File inspectorを選択し、<code>Model Version -&gt; Current</code> で、追加した方（Model2）を選択する</li>
<li>Model2.xcdatamodeledにチェックマークがつく</li>
</ul>


<p><img src="/images/2014/0822/changeCurrent.png" alt="changeVersion" /></p>

<h2>属性名の変更など</h2>

<p>属性名の変更などについては、Lightweightマイグレーションという手法を使用するらしい（未検証）  。<br/>
また、マッピングモデルを使ったマイグレーションも存在するらしい（未検証）。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.raywenderlich.com/56879/magicalrecord-tutorial-ios">http://www.raywenderlich.com/56879/magicalrecord-tutorial-ios</a></li>
<li>iOS Core Data 徹底入門（10章）</li>
</ul>

]]></content>
  </entry>
  
</feed>
