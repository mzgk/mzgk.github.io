<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | jubilee]]></title>
  <link href="http://mzgk.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://mzgk.github.io/"/>
  <updated>2014-08-21T15:22:07+09:00</updated>
  <id>http://mzgk.github.io/</id>
  <author>
    <name><![CDATA[mzgk]]></name>
    <email><![CDATA[mzgkworks@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[キーボードの上に閉じるボタンを表示する（inputAccessoryView）]]></title>
    <link href="http://mzgk.github.io/blog/2014/keyboard-close-inputaccessoryview/"/>
    <updated>2014-08-21T15:03:05+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/keyboard-close-inputaccessoryview</id>
    <content type="html"><![CDATA[<p>UITextViewなどでキーボードを閉じたい時に、キーボードの上部に閉じるボタンを追加して閉じる方法。<br/>
inputAccessoryViewといって、キーボード上部にボタンなどを配置できる。<br/>
キーボードの表示／非表示に合わせて、表示／非表示される。</p>

<h2>生成</h2>

<p>```objective-c
&ndash; (void)viewDidLoad
{
&hellip;</p>

<pre><code>// ボタンを配置するUIViewを作成（幅320／高さ44・背景色：透明）
UIView* accessoryView =[[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 44)];
accessoryView.backgroundColor = [UIColor clearColor];

// ボタンを作成（accessoryView内で、X:270 Y:5 Width:40 Height:30にイメージ有りボタン）
UIButton* closeButton = [UIButton buttonWithType:UIButtonTypeCustom];
[closeButton setImage:[UIImage imageNamed:@"hideKeyboard"] forState:UIControlStateNormal];
closeButton.contentMode = UIViewContentModeScaleAspectFit;
closeButton.frame = CGRectMake(270, 5, 40, 30);
// ボタンタップ時のメソッドを指定（closeKeyboard:　→　自作メソッド）
[closeButton addTarget:self action:@selector(closeKeyboard:) forControlEvents:UIControlEventTouchUpInside];

// ボタンをViewに追加
[accessoryView addSubview:closeButton];

// ビューをUITextFieldのinputAccessoryViewに設定
_textView.inputAccessoryView = accessoryView;
</code></pre>

<p>&hellip;
}
```</p>

<h2>ボタンタップ時の処理</h2>

<p>Closeボタン実行時の処理も記述する。</p>

<p>```
&ndash;(void)closeKeyboard:(id)sender
{</p>

<pre><code>[self.view endEditing:YES];
</code></pre>

<p>}
```</p>

<h2>関連</h2>

<p>UITextView関連では、以下もあり。<br/>
<a href="http://mzgk.github.io/blog/2014/uiscrollview-tapevent/">http://mzgk.github.io/blog/2014/uiscrollview-tapevent/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[セルに追加したボタンの処理をViewControllerで行う]]></title>
    <link href="http://mzgk.github.io/blog/2014/handle-button-in-cell/"/>
    <updated>2014-08-14T20:11:37+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/handle-button-in-cell</id>
    <content type="html"><![CDATA[<p>カスタムセルに追加したボタンの処理を、ViewControllerで行う方法。<br/>
タップされたボタンのセルのインデックスの取得。</p>

<h2>Cell</h2>

<ol>
<li>StoryBoard上でセル内にボタンを追加する</li>
<li>Attribute inspector &ndash; view &ndash; Tag に値を設定する</li>
<li>Outlet接続のみ行う（不要かも）</li>
</ol>


<h2>ViewController</h2>

<h3>ボタンのプロパティを宣言</h3>

<p><code>objective-c
@property (weak, nonatomic) UIButton *button;
</code></p>

<h3>ボタンとタップ時の処理を作成する</h3>

<p>任意の場所で。</p>

<p><code>objective-c
// Cellにボタンを設定した時のTag値
_button = (UIButton*)[cell viewWithTag:1];
// ボタンのイベントを登録
[_button addTarget:self action:@selector(buttonTapped:event:) forControlEvents:UIControlEventTouchUpInside];
</code></p>

<h3>タップ時の処理</h3>

<p>```objective-c
&ndash; (void)buttonTapped:(id)sender event:(UIEvent*)event
{</p>

<pre><code>// タップされたボタンのセルインデックスを取得する
UITouch *touch = [[event allTouches]anyObject];
CGPoint point = [touch locationInView:_sampleTableView];
_tappedIndexPath = [_sampleTableView indexPathForRowAtPoint:point];

// 実行したい処理
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li><a href="http://cocoadays.blogspot.jp/2011/06/ios-uinib-uitableviewcell_26.html">http://cocoadays.blogspot.jp/2011/06/ios-uinib-uitableviewcell_26.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[指定したセルの表示更新を行う]]></title>
    <link href="http://mzgk.github.io/blog/2014/update-selected-cell/"/>
    <updated>2014-08-14T20:09:55+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/update-selected-cell</id>
    <content type="html"><![CDATA[<p>特定のセルのみの表示更新を行いたい場合の方法。<br/>
以下のようなパターンで必要になった。</p>

<ol>
<li>セルをスワイプして削除ボタンを表示し、削除ボタンをタップ</li>
<li>セル内のデータに基づく内部データを処理（セル自体は削除したくない）</li>
<li>削除ボタンが消せない（reloadData）</li>
<li>セルのみ更新をしたい</li>
</ol>


<p>```objective-c
&ndash; (void)tableView:(UITableView <em>)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>if (editingStyle == UITableViewCellEditingStyleDelete) {
    // セルの削除ボタンでしたい処理
    ...
    // 処理したセルの更新↓↓↓
    NSArray *indexPaths = [NSArray arrayWithObject:indexPath];
    [self.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationRight];
    // ↑↑↑
} else if (editingStyle == UITableViewCellEditingStyleInsert) {
}
</code></pre>

<p>}
```</p>

<h2>更新時のアニメーション</h2>

<ul>
<li>UITableViewRowAnimationFade</li>
<li>UITableViewRowAnimationRight</li>
<li>UITableViewRowAnimationLeft</li>
<li>UITableViewRowAnimationTop</li>
<li>UITableViewRowAnimationBottom</li>
<li>UITableViewRowAnimationNone</li>
<li>UITableViewRowAnimationMiddle</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIImageView内に表示する画像の表示モード]]></title>
    <link href="http://mzgk.github.io/blog/2014/uiimageview-contentmode/"/>
    <updated>2014-08-14T20:09:19+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/uiimageview-contentmode</id>
    <content type="html"><![CDATA[<p>UIImageView内に表示する画像の表示モードを指定する方法。</p>

<h2>指定方法</h2>

<p><code>objective-c
_imageView.contentMode = UIViewContentModeCenter;
</code></p>

<h2>モード</h2>

<p>```objective-c
typedef NS_ENUM(NSInteger, UIViewContentMode) {</p>

<pre><code>UIViewContentModeScaleToFill,
UIViewContentModeScaleAspectFit,      // contents scaled to fit with fixed aspect. remainder is transparent
UIViewContentModeScaleAspectFill,     // contents scaled to fill with fixed aspect. some portion of content may be clipped.
UIViewContentModeRedraw,              // redraw on bounds change (calls -setNeedsDisplay)
UIViewContentModeCenter,              // contents remain same size. positioned adjusted.
UIViewContentModeTop,
UIViewContentModeBottom,
UIViewContentModeLeft,
UIViewContentModeRight,
UIViewContentModeTopLeft,
UIViewContentModeTopRight,
UIViewContentModeBottomLeft,
UIViewContentModeBottomRight,
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アプリの標準言語を日本語のみにする方法]]></title>
    <link href="http://mzgk.github.io/blog/2014/localization-japanese-only/"/>
    <updated>2014-08-12T17:39:06+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/localization-japanese-only</id>
    <content type="html"><![CDATA[<p>日本国内のみの配布などで、アプリの標準言語を日本語のみにする設定する方法。<br/>
アプリ作成時のデフォルトは英語になっており、UIImagePickerなどを使用してカメラ機能を実装した場合には、Cancel / Retakeなど英語で表示がされる。 これを日本語に変える。
ただし、通常のlocalization対応と違い日本語オンリーにする対応。</p>

<h2>Localization native development</h2>

<ol>
<li>プロジェクトナビゲーターでプロジェクトを選択 &ndash; Target &ndash; Infoを開く</li>
<li>Localization native development region &ndash; en → Japanに変更する
<img src="/images/2014/0812/localization-1.png" alt="localization-1" /></li>
</ol>


<h2>Localizations</h2>

<ol>
<li>上記の設定後に、そのままの場所で右クリック → Add Row</li>
<li>Keyに「Localizations」を追加する</li>
<li>Item0を選択し、Valueの値を「Japanese」に変更する
<img src="/images/2014/0812/localization-2.png" alt="localization-2" /></li>
</ol>

]]></content>
  </entry>
  
</feed>
