<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | jubilee]]></title>
  <link href="http://mzgk.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://mzgk.github.io/"/>
  <updated>2014-08-05T17:05:25+09:00</updated>
  <id>http://mzgk.github.io/</id>
  <author>
    <name><![CDATA[mzgk]]></name>
    <email><![CDATA[mzgkworks@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[カテゴリファイルの作り方]]></title>
    <link href="http://mzgk.github.io/blog/2014/make-category/"/>
    <updated>2014-08-05T16:49:30+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/make-category</id>
    <content type="html"><![CDATA[<p>カテゴリファイルを作る際の命名方法。<br/>
カテゴリーファイルを選択して、</p>

<p><img src="/images/2014/0805/Category.png" alt="Xcode" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カメラで撮影した動画をフレーム分割する方法]]></title>
    <link href="http://mzgk.github.io/blog/2014/video-devide/"/>
    <updated>2014-08-05T16:24:50+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/video-devide</id>
    <content type="html"><![CDATA[<p>UIImagePickerで撮影した動画を1秒30フレーム程度で、分割し静止画にする方法。</p>

<p>```objective-c
/<em>!
 * 撮影ボタン（作成する）
 </em>/
&ndash; (IBAction)shutterButtonTapped:(id)sender {</p>

<pre><code>// UIImagePickerで動画の撮影をする
UIImagePickerController *picker = [[UIImagePickerController alloc]init];
picker.sourceType = UIImagePickerControllerSourceTypeCamera;
picker.mediaTypes = @[(NSString *)kUTTypeMovie];
picker.cameraCaptureMode = UIImagePickerControllerCameraCaptureModeVideo;
picker.videoQuality = UIImagePickerControllerQualityType640x480;
picker.videoMaximumDuration = 10;
picker.allowsEditing = NO;
picker.delegate = self;
[self presentViewController:picker animated:YES completion:nil];
</code></pre>

<p>}</p>

<p>/<em>!
 * 撮影終了のタイミング
 </em>/
&ndash; (void)imagePickerController:(UIImagePickerController <em>)picker didFinishPickingMediaWithInfo:(NSDictionary </em>)info
{</p>

<pre><code>// UIImagePickerをしまう
[picker dismissViewControllerAnimated:YES completion:nil];

// ~/Documentsディレクトリの取得
NSArray *directories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentDirectory = directories[0];

// 撮影した動画をAssetに格納
NSURL *assetURL = info[UIImagePickerControllerMediaURL];
AVURLAsset *asset = [[AVURLAsset alloc]initWithURL:assetURL options:nil];

// 動画を切り出す間隔を配列に格納する
Float64 frameParSecond = 0.033f;
Float64 durationSeconds = CMTimeGetSeconds([asset duration]);   // 動画の長さ
Float64 frameTimeStamp = 0;
NSMutableArray *times  = [NSMutableArray array];
while (frameTimeStamp &lt;= durationSeconds) {
    [times addObject:[NSValue valueWithCMTime:CMTimeMakeWithSeconds(frameTimeStamp, 600)]];
    CMTime nextTime = CMTimeMakeWithSeconds(frameTimeStamp, 600);
    frameTimeStamp = CMTimeGetSeconds(nextTime) + frameParSecond;
}

// 画像ジェネレーターを生成
AVAssetImageGenerator *generator = [[AVAssetImageGenerator alloc]initWithAsset:asset];
generator.appliesPreferredTrackTransform = YES;
generator.requestedTimeToleranceBefore = kCMTimeZero;
generator.requestedTimeToleranceAfter = kCMTimeZero;

// 一連の画像を生成（timesに格納されている分だけ、第２引数がコールバックされる）
[generator generateCGImagesAsynchronouslyForTimes:times
                                completionHandler:^(CMTime requestedTime, CGImageRef image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError *error) {
                                    NSString *requestedTimeString = (NSString*)CFBridgingRelease(CMTimeCopyDescription(NULL, requestedTime));
                                    NSString *acturalTimeString = (NSString*)CFBridgingRelease(CMTimeCopyDescription(NULL, actualTime));
                                    NSLog(@"Requested: %@; actual: %@", requestedTimeString, acturalTimeString);
                                    if (result == AVAssetImageGeneratorSucceeded) {
                                        // JPEG画像を生成し、保存する
                                        [self writeCGImageTo:documentDirectory image:image];
                                        // iCnt++;
                                        // 完了した判断はtimesの個数と保存した個数でする？
                                        // [times count] == iCntだったら、SVProgressHub停止みたいな
                                    }
                                    if (result == AVAssetImageGeneratorFailed) {
                                        NSLog(@"Failed with error: %@", [error localizedDescription]);
                                    }
                                    if (result == AVAssetImageGeneratorCancelled) {
                                        NSLog(@"Cancelled");
                                    }
                                }];
</code></pre>

<p>}</p>

<p>/<em>!
 * 動画から切り出されたCGImageRef形式のデータをJPEG画像（ファイル名は連番：imageNameNumber）に生成し、指定ディレクトリに書き出す
 </em>/
&ndash; (BOOL)writeCGImageTo:(NSString*)path image:(CGImageRef)cgImage
{</p>

<pre><code>NSLog(@"Called");

NSString *str = [NSString stringWithFormat:@"img_%@.jpg", @(self.imageNameNumber++)];
path = [path stringByAppendingPathComponent:str];

UIImage *saveImage = [UIImage imageWithCGImage:cgImage];
NSData *data = UIImageJPEGRepresentation(saveImage, 1.0);   // 0.0（低水準）〜1.0（高水準）
BOOL result = [data writeToFile:path atomically:YES];
return result;
</code></pre>

<p>}
```</p>

<p>参考：公式の「AVFoundationプログラミングガイド」P17 アセットの使用　ビデオから静止画像の取得　一連の画像の生成</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[シングルトン（singleton）]]></title>
    <link href="http://mzgk.github.io/blog/2014/singleton/"/>
    <updated>2014-08-05T16:14:13+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/singleton</id>
    <content type="html"><![CDATA[<p>シングルトンとは？</p>

<ul>
<li>デザインパターンの１つ</li>
<li>「ただ１つの」インスタンスしか持たない→どこからアクセスしても同じインスタンス</li>
<li>複数のクラス間での変数やオブジェクトの共有が可能</li>
<li>複数のクラス間でメソッドの共有ができる</li>
<li>NSUserdefaultsと同様</li>
</ul>


<h3>SingletonManager.h</h3>

<p>```objective-c
@interface SingletonSample : NSObject
// このシングルトンが管理するプロパティ
@property(nonatomic) NSInteger managedParam;
@property(strong, nonatomic) NSString <em>catName;
&hellip;
// インスタンス作成のためのクラスメソッド
+ (SingletonSample </em>)sharedManager;</p>

<p>// このシングルトンが保有するメソッド
&ndash; (void)sampleMethod:(NSString*)name;
@end
```</p>

<h3>SingletonManager.m</h3>

<p>```objective-c
@implementation SingletonManager</p>

<p>static id sharedManager_ = nil;
+ (id)sharedManager
{</p>

<pre><code>static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    sharedData_ = [SingletonManager new];
});
return sharedManager_;
</code></pre>

<p>}</p>

<ul>
<li>(void)sampleMethod:(NSString*)name
{
  &hellip;
}
@end
```</li>
</ul>


<h3>ViewController.m</h3>

<p>```objective-c</p>

<h1>import &ldquo;SingletonManager.h&rdquo;</h1>

<ul>
<li>(void)viewDidLoad
{
  SingletonManager *single = [SingletonManager sharedManager];
  single.managedParam = 100; // 変数に値をセット
  [single sampleMethod:name]; // メソッドを使用
}
```</li>
</ul>


<p>参考：<br/>
<a href="http://ylb.jp/iOSDev/SingletonSample.pdf  ">http://ylb.jp/iOSDev/SingletonSample.pdf  </a>
<a href="http://qiita.com/yuky_az/items/27031ec5ca55a95d6209">http://qiita.com/yuky_az/items/27031ec5ca55a95d6209</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ビューの重なり順を変更する]]></title>
    <link href="http://mzgk.github.io/blog/2014/chage-view-overlap/"/>
    <updated>2014-08-05T15:34:39+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/chage-view-overlap</id>
    <content type="html"><![CDATA[<p>ビューの重なり順をコードで変更する方法。</p>

<h2>自分に追加されているサブビューの配列を取得</h2>

<p><code>objective-c
self.subviews
</code></p>

<h2>自分と同じスーパービューをもつサブビューの配列を取得</h2>

<p><code>objective-c
superview.subviews
</code></p>

<h2>挿入位置をインデックス番号で指定する</h2>

<p><code>objective-c
[self.view insertSubview:_imageView atIndex:1];
</code></p>

<h2>指定ビューの前／後ろに挿入する</h2>

<p><code>objective-c
// _targetViewの下にする
[self.view insertSubview:_imageView belowSubview:_targetView];
// _targetViewの上にする
[self.view insertSubview:_imageView aboveSubview:_targetView];
</code></p>

<h2>ビューを最前面／再背面に移動させる</h2>

<p><code>objective-c
// 最前面
[self.view bringSubviewToFront:_imageView];
// 再背面
[self.view sendSubviewToBack:_imageView];
</code></p>

<h2>指定したインデックスのビューの重なりを入れ替える</h2>

<p><code>objective-c
// 1番目と3番目を入れ替える
[self.view exchangeSubviewAtIndex:1 withSubviewAtIndex:3];
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ファイルパス（NSString）をNSURLに変換する方法（日本語OK）]]></title>
    <link href="http://mzgk.github.io/blog/2014/filepath-nsurl/"/>
    <updated>2014-08-05T15:07:00+09:00</updated>
    <id>http://mzgk.github.io/blog/2014/filepath-nsurl</id>
    <content type="html"><![CDATA[<p>日本語のディレクトリ名が入るとおかしくなるが、この方法だとOK。</p>

<p><code>objective-c
NSString* string = @"/Users/abt/Documents/日本語のフォルダ名/file.txt";
NSURL* url = [NSURL fileURLWithPath:string];
// NGケース（nilが返る）
NSURL* nilUrl = [NSURL URLWithString:string];
</code></p>
]]></content>
  </entry>
  
</feed>
